The library has been developed based on the following design principles:

Rule 1: Each application that composes the distributed system may declare and handle any exception. The library does not impose the usage of some specific exceptions.

Rule 2: Raised exceptions that must be returned to the caller of a REST endpoint must be handled by an @ExceptionHandler. That handler will determine the HTTP status code to be returned and optionally log the error and generate an alert. Application should use the GlobalControllerExceptionHandler provided with the library. That class handles a set of common exceptions. Application can define additional @ExceptionHandler classes and use @Order to define the precedence of the exception handlers.

Rule 3: Raised exceptions must be logged. Use the logging library for that purpose. The metadata log files will be continuously scanned for errors and the development team that owns the application will be notified by mail. Dedicated dashboard will also be made accessible.

Rule 4: Raised exceptions can also trigger the generation of an alert. Use the logging library for that purpose. Alerts should be avoided as much as possible and only reserved to report severe problems that must be handled immediately. Each generated alert will be processed within a given SLA using an incident resolution document that has to be provided with the application. Detecting that a REST endpoint has been called with invalid argument, data validation errors, a REST endpoint that replies with a HTTP400 or even HTTP 500 are examples where no alert should be raised. These errors will be logged and developers notified as per Rule 3.    

Rule 5: The HTTP responses that report an error because of a raised exception should have as body the serialization of an ErrorDetail in JSON format. An ErrorDetail provides additional information about the error and is complementary to the returned HTTP status code error. ErrorDetail defines a field isAlertCreated that indicates if the application that raised the error also created an alert for it. That information can be used by the caller of a REST endpoint to avoid to create on its turn an alert which could be a duplicate.

Rule 6: The information contained in ErrorDetail should not be exposed to the outside. It can be produced as answer to calls issued from other internal applications of the distributed system. GlobalControllerExceptionHandler – the @ExceptionHandler provided by the library – automatically includes an ErrorDetail in the body of HTTP responses that report errors. This is done only if the application declares a logger.alert.isInternalApplication=true property. That property can only be set by applications that are not exposing any REST endpoints to the outside. 

Rule 7: Being part of a distributed system, each application has to handle possible communication issues and unavailability of other applications with which it communicates. The library provides the RegistryRestTemplateExecutor class that defines a single performCall() method taking as argument any operation that can be performed on a RestTemplate. The performCall() takes care to execute that operation and to handle any error. All errors related to IO communication, data serialization/deserialization issues or the callee replying with an HTTP error status are covered. Such errors will cause the generation of the following exceptions:
RemoteInfrastructureException: to report IO communication issues. The GlobalControllerExceptionHandler handles that exception by generating an alert and by returning an HTTP 500 status code
ResourceNotFoundException: when a callee replied with a HTTP 404. GlobalControllerExceptionHandler generates an alert only if the HTTP response body does not contain an ErrorDetail. That absence indicates that the 404 has been generated by the web server or by the Spring web dispatcher because they cannot find the requested resource in which case the error is severe. An ErrorDetail will be present when the 404 is generated by the application itself to notify that the requested data couldn’t be found. In that case no alert will be generated because the error only concerns data. 
SetupException: when the callee replied with a 401 or 403. GlobalControllerExceptionHandler handles that exception by returning a HTTP 403 status code and always creates an alert. That exception is raised when an application refuses the processing of a user request because it has missing grants (403) or is raised by an application because another application is calling one of its REST endpoint without the correct authentication credentials (401).
RemoteIssueException: when the callee replied with any HTTP status other than 200, 401, 403 and 404. No alert is generated by GlobalControllerExceptionHandler. The error is logged and so the development team will be notified by email. Note that it has been deliberately chosen to not create alerts for HTTP status codes in the 500 range. The reason is that in the vast majority of occurrences, 500 codes do not report critical issues. They are mostly caused by unexpected exceptions like NullPointerException, IllegalArgumentException, IndexOutOfBoundsException. The user will not receive the data to its requests, the development team will be notified by email but it is not necessary to take further action like the application restart.  
